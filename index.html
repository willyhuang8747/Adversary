<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>最初的敵對者格擋練習</title>
    <style>
        body { font-family: 'Microsoft JhengHei', sans-serif; display: flex; flex-direction: column; align-items: center; background: #1a1a1a; color: white; padding: 50px 0; margin: 0; }
        .test-section { background: #252525; padding: 30px; border-radius: 15px; margin-bottom: 80px; display: flex; flex-direction: column; align-items: center; border: 1px solid #333; width: 700px; }
        h2 { color: #e74c3c; margin-top: 0; }
        .game-container { position: relative; width: 600px; height: 400px; background: #000; display: flex; justify-content: center; align-items: center; border: 2px solid #111; margin: 20px 0; overflow: hidden; }
        .skill-gif, .freeze-canvas { max-width: 100%; max-height: 100%; position: absolute; }
        .skill-gif { display: none; }
        .freeze-canvas { display: none; }
        .result-text {
        font-size: 24px;       /* 稍微調小一點點，換行才不會太擁擠 */
        font-weight: bold;
        margin: 15px 0;
        min-height: 40px;      /* 改為最小高度，讓它隨內容撐開 */
        height: auto;          /* 確保高度是自動的 */
        line-height: 1.5;      /* 設定行高，讓換行有間距 */
        text-align: center;
        }
        .success { color: #4CAF50; text-shadow: 0 0 10px #4CAF50; }
        .fail { color: #FF5252; text-shadow: 0 0 10px #FF5252; }
        .early { color: #FFC107; text-shadow: 0 0 10px #FFC107; }
        .status-box { background: #111; padding: 10px 20px; border-radius: 8px; text-align: center; width: 100%; box-sizing: border-box; }
        .timing-info { font-family: monospace; color: #888; font-size: 14px; margin-top: 5px; }
        .start-btn { padding: 12px 40px; font-size: 18px; cursor: pointer; background: #2ecc71; color: white; border: none; border-radius: 5px; margin-top: 20px; transition: 0.2s; }
        .start-btn:hover { background: #27ae60; transform: scale(1.05); }
        .start-btn:disabled { background: #444; cursor: not-allowed; transform: none; }
        hr { border: 0; border-top: 1px solid #444; width: 100%; margin: 40px 0; }
        .setting-panel { background: #333; padding: 15px; border-radius: 10px; margin-bottom: 20px; border: 1px solid #e74c3c; text-align: center; display: flex; gap: 20px; justify-content: center; }
        .setting-item { display: flex; flex-direction: column; align-items: center; }
        .setting-item label { margin-bottom: 5px; font-size: 14px; }
        .key-input { background: #1a1a1a; color: white; border: 1px solid #555; padding: 5px; width: 100px; text-align: center; cursor: pointer; font-weight: bold; }
    </style>
</head>
<body>

    <h1>最初的敵對者格擋練習</h1>
    
    <div class="setting-panel">
        <div class="setting-item">
            <label>採集鍵 (預設 Alt)：</label>
            <input type="text" id="customKeyInput" class="key-input" value="Alt" readonly onclick="setupKeyCapture('alt')">
        </div>
        <div class="setting-item">
            <label>跳躍鍵 (預設 Space)：</label>
            <input type="text" id="customSpaceInput" class="key-input" value="Space" readonly onclick="setupKeyCapture('space')">
        </div>
        <div style="align-self: flex-end; font-size: 12px; color: #aaa; padding-bottom: 10px;">(點擊輸入框後按下按鍵即可設定)</div>
    </div>

    <p style="color: #666;">向下捲動選擇練習項目</p>

    <div class="test-section" id="section-0">
        <h2>一階二連斬</h2>
        <div class="status-box">
            <div class="result-text">準備就緒</div>
            <div class="timing-info">目標區間：1.420s ~ 1.960s</div>
            <div class="timing-info">按下瞬間：<span class="player-time">0.000</span>s</div>
        </div>
        <div class="game-container"><img class="skill-gif" src=""><canvas class="freeze-canvas"></canvas></div>
        <button class="start-btn" onclick="startTrial(0)">開始測試</button>
    </div>

    <div class="test-section" id="section-1">
        <h2>一階三連斬</h2>
        <div class="status-box">
            <div class="result-text">準備就緒</div>
            <div class="timing-info">目標區間：2.730s ~ 3.240s</div>
            <div class="timing-info">按下瞬間：<span class="player-time">0.000</span>s</div>
        </div>
        <div class="game-container"><img class="skill-gif" src=""><canvas class="freeze-canvas"></canvas></div>
        <button class="start-btn" onclick="startTrial(1)">開始測試</button>
    </div>

    <div class="test-section" id="section-2">
        <h2>分身術</h2>
        <div class="status-box">
            <div class="result-text">準備就緒</div>
            <div class="timing-info">目標區間：2.14s ~ 2.64s</div>
            <div class="timing-info">按下瞬間：<span class="player-time">0.000</span>s</div>
        </div>
        <div class="game-container"><img class="skill-gif" src=""><canvas class="freeze-canvas"></canvas></div>
        <button class="start-btn" onclick="startTrial(2)">開始測試</button>
    </div>

    <div class="test-section" id="section-3">
        <h2>單衝(分身) (下 + <span class="displayKeyAlt">Alt</span>)</h2>
        <div class="status-box">
            <div class="result-text" id="result-3">準備就緒</div>
            <div class="timing-info">目標 1 (↓)：0.00s~1.38s | 目標 2 (<span class="displayKeyAlt">Alt</span>)：2.07s~2.57s</div>
            <div class="timing-info">按下時間 1：<span class="player-time-0">0.000</span>s | 按下時間 2：<span class="player-time-1">0.000</span>s</div>
        </div>
        <div class="game-container"><img class="skill-gif" src=""><canvas class="freeze-canvas"></canvas></div>
        <button class="start-btn" onclick="startTrial(3)">開始測試</button>
    </div>

    <div class="test-section" id="section-4">
        <h2>三連衝1(分身) (下 + <span class="displayKeyAlt">Alt</span>)</h2>
        <div class="status-box">
            <div class="result-text" id="result-4">準備就緒</div>
            <div class="timing-info">目標 1 (↓)：0.00s~2.356s | 目標 2 (<span class="displayKeyAlt">Alt</span>)：2.54s~3.354s</div>
            <div class="timing-info">按下時間 1：<span class="player-time-0">0.000</span>s | 按下時間 2：<span class="player-time-1">0.000</span>s</div>
        </div>
        <div class="game-container"><img class="skill-gif" src=""><canvas class="freeze-canvas"></canvas></div>
        <button class="start-btn" onclick="startTrial(4)">開始測試</button>
    </div>

    <div class="test-section" id="section-5">
        <h2>三連衝2</h2>
        <div class="status-box">
            <div class="result-text">準備就緒</div>
            <div class="timing-info">目標區間：0s ~ 0.947s</div>
            <div class="timing-info">按下瞬間：<span class="player-time">0.000</span>s</div>
        </div>
        <div class="game-container"><img class="skill-gif" src=""><canvas class="freeze-canvas"></canvas></div>
        <button class="start-btn" onclick="startTrial(5)">開始測試</button>
    </div>

    <div class="test-section" id="section-6">
        <h2>三連衝3(分身) ( <span class="displayKeySpace">Space</span> + <span class="displayKeyAlt">Alt</span>)</h2>
        <div class="status-box">
            <div class="result-text" id="result-6">準備就緒</div>
            <div class="timing-info">目標 1 (<span class="displayKeySpace">Space</span>)：0.00s~1.702s | 目標 2 (<span class="displayKeyAlt">Alt</span>)：2.465s~3.111s</div>
            <div class="timing-info">按下時間 1：<span class="player-time-0">0.000</span>s | 按下時間 2：<span class="player-time-1">0.000</span>s</div>
        </div>
        <div class="game-container"><img class="skill-gif" src=""><canvas class="freeze-canvas"></canvas></div>
        <button class="start-btn" onclick="startTrial(6)">開始測試</button>
    </div>

    <div class="test-section" id="section-7">
        <h2>三連衝(連續)</h2>
        <div class="status-box">
            <div class="result-text" id="result-7">準備就緒</div>
            <div class="timing-info">當前進度：<span id="combo-stage">-</span> / 3</div>
        </div>
        <div class="game-container">
            <img class="skill-gif" id="combo-gif" src="">
            <canvas class="freeze-canvas"></canvas>
        </div>
        <button class="start-btn" onclick="startComboTrial()">開始連續測試</button>
    </div>
<script>
    var configs = [
        { src: "src/一階二連斬.gif", total: 2820, keys: [{ label: "格檔", key: "Alt", start: 1.42, end: 1.96 }] },
        { src: "src/一階三連斬.gif", total: 3720, keys: [{ label: "格檔", key: "Alt", start: 2.73, end: 3.24 }] },
        { src: "src/分身術.gif", total: 4080, keys: [{ label: "格檔", key: "Alt", start: 2.14, end: 2.64 }] },
        { src: "src/單衝(分身).gif", total: 3420, keys: [{ label: "分身", key: "ArrowDown", start: 0, end: 1.38 }, { label: "本尊", key: "Alt", start: 2.07, end: 2.57 }] },
        { src: "src/三連衝1(分身).gif", total: 4020, keys: [{ label: "分身", key: "ArrowDown", start: 0, end: 2.356 }, { label: "本尊", key: "Alt", start: 2.54, end: 3.354 }] },
        { src: "src/三連衝2.gif", total: 1560, keys: [{ label: "趴下", key: "ArrowDown", start: 0, end: 0.947 }] },
        { src: "src/三連衝3(分身).gif", total: 4050, keys: [{ label: "分身", key: " ", start: 0, end: 1.702 }, { label: "本尊", key: "Alt", start: 2.465, end: 3.111 }] }
    ];

    var activeIndex = -1;
    // --- 連續技專用變數 ---
    var isComboMode = false;
    var comboSequence = [4, 5, 6]; 
    var comboPointer = 0;
    var comboResults = []; 
    var comboTimes = [];   
    // ----------------------
    var startTime = 0;
    var userPressTimes = {};
    var gifTimer = null;
    // --- 核心按鍵變數 ---
    var userDefinedKey = "Alt"; // 預設格擋鍵
    var userDefinedSpaceKey = " "; // 預設跳躍鍵
    var currentCaptureHandler = null;

    function setupKeyCapture(type) {
        // 1. 如果之前已經有一個監聽器在跑，先把它移除，防止多重觸發
        if (currentCaptureHandler) {
            window.removeEventListener('keydown', currentCaptureHandler, true);
        }

        const input = (type === 'alt') ? document.getElementById('customKeyInput') : document.getElementById('customSpaceInput');
        const oldVal = input.value;
        input.value = "請按下按鍵...";
        input.style.background = "#444"; 

        // 2. 定義這一次的監聽邏輯
        currentCaptureHandler = function(e) {
            e.preventDefault();
            e.stopPropagation();

            const displayVal = (e.key === " ") ? "Space" : e.key;

            // 根據傳入的 type (alt 或 space) 嚴格更新對應變數
            if (type === 'alt') {
                userDefinedKey = e.key; // 只更新格擋鍵
                document.querySelectorAll('.displayKeyAlt').forEach(el => el.textContent = displayVal);
                if(document.getElementById('displayKey')) document.getElementById('displayKey').textContent = displayVal;
            } else if (type === 'space') {
                userDefinedSpaceKey = e.key; // 只更新跳躍鍵
                document.querySelectorAll('.displayKeySpace').forEach(el => el.textContent = displayVal);
            }

            input.value = displayVal;
            input.style.background = "#333";
            
            // 3. 完成後移除監聽並清空暫存變數
            window.removeEventListener('keydown', currentCaptureHandler, true);
            currentCaptureHandler = null;
        };

        // 使用 true (捕獲階段) 確保優先級最高，攔截一切系統預設鍵
        window.addEventListener('keydown', currentCaptureHandler, true);
    }    
    function startTrial(idx) {
        if (activeIndex !== -1) return;
        activeIndex = idx;
        var config = configs[idx];
        var section = document.getElementById("section-" + idx);
        userPressTimes = {};
        section.querySelector('.start-btn').disabled = true;
        section.querySelector('.result-text').textContent = "觀察中...";
        section.querySelector('.result-text').className = "result-text";
        var spans = section.querySelectorAll('[class*="player-time"]');
        for (var i = 0; i < spans.length; i++) { spans[i].textContent = "0.000"; }
        var gif = section.querySelector('.skill-gif');
        var canvas = section.querySelector('.freeze-canvas');
        canvas.style.display = "none";
        gif.style.display = "block";
        gif.src = config.src + "?t=" + new Date().getTime();
        startTime = performance.now();
        if (gifTimer) clearTimeout(gifTimer);
        gifTimer = setTimeout(function() { endTrial(idx); }, config.total);
    }

    function endTrial(idx) {
        var config = configs[idx];
        var section = document.getElementById("section-" + idx);
        var gif = section.querySelector('.skill-gif');
        var canvas = section.querySelector('.freeze-canvas');
        var ctx = canvas.getContext('2d');
        var resultDisplay = section.querySelector('.result-text');
        canvas.width = gif.naturalWidth;
        canvas.height = gif.naturalHeight;
        ctx.drawImage(gif, 0, 0, canvas.width, canvas.height);
        gif.style.display = "none";
        canvas.style.display = "block";
        var isAllSuccess = true;
        var results = [];
        for (var k = 0; k < config.keys.length; k++) {
            var target = config.keys[k];
            var pTime = userPressTimes[k];
            var label = target.label || "判定";
            if (pTime === undefined) { results.push(label + ":未按"); isAllSuccess = false; }
            else if (pTime >= target.start && pTime <= target.end) { results.push(label + ":成功"); }
            else if (pTime < target.start) { results.push(label + ":太早"); isAllSuccess = false; }
            else { results.push(label + ":太晚"); isAllSuccess = false; }
        }
        resultDisplay.textContent = results.join(" | ");
        resultDisplay.className = "result-text " + (isAllSuccess ? "success" : "fail");
        activeIndex = -1;
        section.querySelector('.start-btn').disabled = false;
    }

    window.addEventListener('keydown', function(e) {
        // 如果沒有正在進行測驗，則不執行邏輯（允許正常使用方向鍵捲動網頁）
        if (activeIndex === -1) return;

        // 1. 強制攔截所有功能鍵，防止按下 Alt 彈出選單、按下 Space 或方向鍵導致網頁捲動
        if (["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight", " ", "Alt"].indexOf(e.key) > -1) {
            e.preventDefault();
        }

        var config = configs[activeIndex];
        var currentTime = (performance.now() - startTime) / 1000;
        
        for (var i = 0; i < config.keys.length; i++) {
            var target = config.keys[i];
            var isMatched = false;

            // 2. 判定邏輯：比對當前按下的 e.key 是否符合設定
            if (target.key === "Alt") {
                // 如果這一關要求「格擋」：按下實體 Alt 鍵 或 使用者自訂的字母鍵都算成功
                if (e.key === "Alt" || e.key.toLowerCase() === userDefinedKey.toLowerCase()) {
                    isMatched = true;
                }
            } else if (target.key === " ") {
                // 如果這一關要求「跳躍」：按下實體空白鍵 或 使用者自訂的字母鍵都算成功
                if (e.key === " " || e.key.toLowerCase() === userDefinedSpaceKey.toLowerCase()) {
                    isMatched = true;
                }
            } else {
                // 其他普通按鍵 (例如方向鍵 ArrowDown 等)
                if (e.key === target.key) {
                    isMatched = true;
                }
            }

            // 3. 執行按鍵成功後的動作
            if (isMatched && userPressTimes[i] === undefined) {
                // 再次確保如果是功能鍵則不觸發預設行為
                if ([" ", "Alt"].indexOf(e.key) > -1) e.preventDefault();

                userPressTimes[i] = currentTime;
                
                // 判斷當前是在普通模式還是連續技(Section-7)模式，以更新正確的 UI 位置
                var sectionId = isComboMode ? "section-7" : "section-" + activeIndex;
                var section = document.getElementById(sectionId);
                
                if (section) {
                    // 尋找對應的秒數顯示標籤
                    var timeSpan = section.querySelector(".player-time-" + i) || section.querySelector(".player-time");
                    if (timeSpan) {
                        timeSpan.textContent = currentTime.toFixed(3);
                    }
                }
            }
        }
    });
    function startComboTrial() {
        isComboMode = true;
        comboPointer = 0;
        comboResults = []; 
        comboTimes = [];
        document.querySelector('#section-7 .start-btn').disabled = true;
        document.getElementById("result-7").textContent = "三連衝中...";
        document.getElementById("result-7").className = "result-text";
        runComboStep();
    }

// 1. 執行每一關的啟動函式
function runComboStep() {
        var targetIdx = comboSequence[comboPointer];
        var config = configs[targetIdx];
        
        // 更新 UI 進度
        document.getElementById("combo-stage").textContent = (comboPointer + 1);
        activeIndex = targetIdx;
        userPressTimes = {};
        
        // 取得 Section 7 內的元素
        var section = document.getElementById("section-7");
        var gif = section.querySelector('.skill-gif');
        var canvas = section.querySelector('.freeze-canvas');

        // 重置顯示狀態：隱藏上次的定格圖，顯示 GIF
        canvas.style.display = "none";
        gif.style.display = "block";
        
        // 加上時間戳確保 GIF 從頭播放
        gif.src = config.src + "?t=" + new Date().getTime();
        
        startTime = performance.now();
        if (gifTimer) clearTimeout(gifTimer);
        gifTimer = setTimeout(function() { 
            endComboStep(targetIdx); 
        }, config.total);
    }

    // 2. 每一關播放結束後的數據紀錄函式
    function endComboStep(idx) {
        var config = configs[idx];
        var currentStepTimes = [];
        var stepSuccess = true;

        // 收集玩家按下的秒數與判定結果
        for (var k = 0; k < config.keys.length; k++) {
            var target = config.keys[k];
            var pTime = userPressTimes[k];
            var timeStr = (pTime !== undefined) ? pTime.toFixed(3) + "s" : "未按";
            currentStepTimes.push(timeStr);

            if (pTime === undefined || pTime < target.start || pTime > target.end) {
                stepSuccess = false;
            }
        }
        
        // 存入全域陣列備用
        comboResults.push(stepSuccess ? "成功" : "失敗");
        comboTimes.push("(" + currentStepTimes.join(",") + ")");

        comboPointer++;
        if (comboPointer < comboSequence.length) {
            // 如果還有下一招，立即播放下一招 (無縫切換)
            runComboStep(); 
        } else {
            // 如果是最後一招 (項目6)，執行最後定格與結算顯示
            finalizeCombo();
        }
    }

    // 3. 全部結束後的結算與定格函式 (新增/完整版)
    function finalizeCombo() {
        isComboMode = false;
        activeIndex = -1;
        var section = document.getElementById("section-7");
        var resultDisplay = document.getElementById("result-7");
        var gif = section.querySelector('.skill-gif');
        var canvas = section.querySelector('.freeze-canvas');
        var ctx = canvas.getContext('2d');

        // --- 執行定格邏輯 ---
        canvas.width = gif.naturalWidth;
        canvas.height = gif.naturalHeight;
        ctx.drawImage(gif, 0, 0, canvas.width, canvas.height);
        
        gif.style.display = "none";      
        canvas.style.display = "block";   

        // --- 自定義名稱與顏色顯示邏輯 ---
        var customNames = ["三連衝1", "三連衝2", "三連衝3"];
        var finalReport = [];
        var allPassed = true;

        for (var i = 0; i < comboSequence.length; i++) {
            var stageName = customNames[i];
            var res = comboResults[i];     // "成功" 或 "失敗"
            var timeDetail = comboTimes[i]; // 例如 "(0.123s)"
            
            // 根據結果決定顏色：成功用綠色(#2ecc71)，失敗用紅色(#e74c3c)
            var textColor = (res === "成功") ? "#2ecc71" : "#e74c3c";
            
            // 將每一行包裝在帶有顏色的 span 中
            finalReport.push("<span style='color:" + textColor + "'>" + stageName + ":" + res + timeDetail + "</span>");
            
            if (res === "失敗") allPassed = false;
        }

        // 1. 使用 innerHTML 渲染包含顏色標籤的文字
        resultDisplay.innerHTML = finalReport.join("<br>");
        
        // 2. 移除原本控制整塊顏色的 success/fail class，避免覆蓋掉內層的顏色
        resultDisplay.className = "result-text"; 
        
        // 如果你希望「全部成功」時背景或邊框有特殊提示，可以保留 class 但要確保 CSS 優先權
        // resultDisplay.classList.add(allPassed ? "success" : "fail");

        // 恢復按鈕與狀態
        section.querySelector('.start-btn').disabled = false;
        document.getElementById("combo-stage").textContent = "完成";
    }
</script>
</body>
</html>